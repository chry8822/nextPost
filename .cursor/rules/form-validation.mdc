---
globs: **/components/**/*.tsx,**/app/**/*.tsx
description: Form handling and validation patterns with React Hook Form and Zod
---

# Form Development & Validation Standards

## üìù FORM ARCHITECTURE (STRICT COMPLIANCE)

### The Complete Form Pattern (FOLLOW EXACTLY)

```typescript
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

// 1. SCHEMA DEFINITION (Always define first)
const formSchema = z.object({
  title: z.string().min(1, 'Title is required').max(100, 'Title must be less than 100 characters'),
  content: z.string().min(10, 'Content must be at least 10 characters').max(5000, 'Content must be less than 5000 characters'),
  email: z.string().email('Please enter a valid email address'),
  tags: z.array(z.string()).min(1, 'At least one tag is required').max(5, 'Maximum 5 tags allowed'),
  published: z.boolean().default(false),
});

type FormData = z.infer<typeof formSchema>;

// 2. FORM COMPONENT
interface FormComponentProps {
  initialData?: Partial<FormData>;
  onSubmit: (data: FormData) => Promise<void>;
  isEditing?: boolean;
}

export default function FormComponent({ initialData, onSubmit, isEditing = false }: FormComponentProps) {
  const [isLoading, setIsLoading] = useState(false);

  // 3. FORM SETUP
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: initialData?.title || '',
      content: initialData?.content || '',
      email: initialData?.email || '',
      tags: initialData?.tags || [],
      published: initialData?.published || false,
    },
  });

  // 4. SUBMIT HANDLER
  const handleSubmit = async (data: FormData) => {
    try {
      setIsLoading(true);
      await onSubmit(data);
      if (!isEditing) {
        form.reset(); // Reset form after successful creation
      }
    } catch (error) {
      console.error('Form submission error:', error);
      // Handle error (show toast, etc.)
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
      {/* Title Field */}
      <div>
        <label htmlFor="title" className="block text-sm font-medium text-gray-700">
          Title
        </label>
        <Input id="title" {...form.register('title')} className={form.formState.errors.title ? 'border-red-500' : ''} disabled={isLoading} />
        {form.formState.errors.title && <p className="mt-1 text-sm text-red-600">{form.formState.errors.title.message}</p>}
      </div>

      {/* Content Field */}
      <div>
        <label htmlFor="content" className="block text-sm font-medium text-gray-700">
          Content
        </label>
        <Textarea id="content" {...form.register('content')} rows={10} className={form.formState.errors.content ? 'border-red-500' : ''} disabled={isLoading} />
        {form.formState.errors.content && <p className="mt-1 text-sm text-red-600">{form.formState.errors.content.message}</p>}
      </div>

      {/* Submit Button */}
      <Button type="submit" disabled={isLoading || !form.formState.isValid} className="w-full">
        {isLoading ? 'Submitting...' : isEditing ? 'Update' : 'Create'}
      </Button>
    </form>
  );
}
```

## üõ°Ô∏è VALIDATION SCHEMAS (ZOD PATTERNS)

### Common Validation Patterns (REUSE THESE)

```typescript
// User validation schemas
export const userValidation = {
  email: z.string().email('Invalid email format').min(1, 'Email is required'),

  username: z
    .string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be less than 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),

  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain uppercase, lowercase, and number'),

  name: z.string().min(2, 'Name must be at least 2 characters').max(50, 'Name must be less than 50 characters').optional(),
};

// Post validation schemas
export const postValidation = {
  title: z.string().min(1, 'Title is required').max(100, 'Title must be less than 100 characters'),

  slug: z
    .string()
    .min(1, 'Slug is required')
    .regex(/^[a-z0-9-]+$/, 'Slug can only contain lowercase letters, numbers, and hyphens'),

  content: z.string().min(10, 'Content must be at least 10 characters').max(50000, 'Content is too long'),

  excerpt: z.string().max(200, 'Excerpt must be less than 200 characters').optional(),

  tags: z.array(z.string()).min(1, 'At least one tag is required').max(10, 'Maximum 10 tags allowed'),
};

// Comment validation schemas
export const commentValidation = {
  content: z.string().min(1, 'Comment cannot be empty').max(1000, 'Comment must be less than 1000 characters'),
};
```

### Schema Composition (ADVANCED PATTERNS)

```typescript
// Base schemas for reuse
const baseUserSchema = z.object({
  email: userValidation.email,
  username: userValidation.username,
  name: userValidation.name,
});

// Registration schema (includes password)
export const registerSchema = baseUserSchema
  .extend({
    password: userValidation.password,
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'],
  });

// Profile update schema (excludes password)
export const updateProfileSchema = baseUserSchema.extend({
  bio: z.string().max(500, 'Bio must be less than 500 characters').optional(),
  website: z.string().url('Please enter a valid URL').optional(),
});

// Post creation schema
export const createPostSchema = z.object({
  title: postValidation.title,
  content: postValidation.content,
  excerpt: postValidation.excerpt,
  tags: postValidation.tags,
  published: z.boolean().default(false),
});

// Post update schema (partial)
export const updatePostSchema = createPostSchema.partial();
```

## üéØ INPUT COMPONENT PATTERNS

### Custom Input Components (WITH VALIDATION)

```typescript
import { forwardRef } from 'react';
import { cn } from '@/lib/utils';

interface ValidatedInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  required?: boolean;
}

const ValidatedInput = forwardRef<HTMLInputElement, ValidatedInputProps>(({ className, label, error, required, ...props }, ref) => {
  return (
    <div className="space-y-2">
      {label && (
        <label className="block text-sm font-medium text-gray-700">
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </label>
      )}
      <input
        className={cn(
          'flex h-9 w-full rounded-md border border-slate-200 bg-white px-3 py-1 text-sm',
          'placeholder:text-slate-500 focus-visible:outline-none focus-visible:ring-1',
          'focus-visible:ring-slate-950 disabled:cursor-not-allowed disabled:opacity-50',
          error && 'border-red-500 focus-visible:ring-red-500',
          className
        )}
        ref={ref}
        {...props}
      />
      {error && <p className="text-sm text-red-600">{error}</p>}
    </div>
  );
});
ValidatedInput.displayName = 'ValidatedInput';

export { ValidatedInput };
```

## üö® CRITICAL FORM RULES

### ‚ùå FORBIDDEN PRACTICES

1. **NEVER** submit forms without validation
2. **NEVER** use uncontrolled inputs for complex forms
3. **NEVER** forget to disable submit button during loading
4. **NEVER** skip error handling in form submission
5. **NEVER** validate only on client-side (always validate server-side too)
6. **NEVER** expose sensitive validation logic to client
7. **NEVER** use inline validation messages without proper UX

### ‚úÖ MANDATORY REQUIREMENTS

1. **ALWAYS** use React Hook Form + Zod resolver
2. **ALWAYS** provide clear, actionable error messages
3. **ALWAYS** implement loading states
4. **ALWAYS** use TypeScript inference from Zod schemas
5. **ALWAYS** validate both client and server side
6. **ALWAYS** provide accessibility attributes
7. **ALWAYS** reset forms after successful submission (for creation)

## üîÑ FORM STATE MANAGEMENT

### Loading and Error States (REQUIRED PATTERNS)

```typescript
export default function FormWithStates() {
  const [isLoading, setIsLoading] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [submitSuccess, setSubmitSuccess] = useState(false);

  const handleSubmit = async (data: FormData) => {
    try {
      setIsLoading(true);
      setSubmitError(null);
      setSubmitSuccess(false);

      await onSubmit(data);

      setSubmitSuccess(true);
      form.reset();
    } catch (error) {
      setSubmitError(error instanceof Error ? error.message : 'Something went wrong');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={form.handleSubmit(handleSubmit)}>
      {/* Form fields */}

      {/* Global error message */}
      {submitError && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <p className="text-sm text-red-800">{submitError}</p>
        </div>
      )}

      {/* Success message */}
      {submitSuccess && (
        <div className="p-4 bg-green-50 border border-green-200 rounded-md">
          <p className="text-sm text-green-800">Form submitted successfully!</p>
        </div>
      )}

      <Button type="submit" disabled={isLoading || !form.formState.isValid}>
        {isLoading ? 'Submitting...' : 'Submit'}
      </Button>
    </form>
  );
}
```

## üì± RESPONSIVE FORM PATTERNS

### Mobile-First Form Layouts

```typescript
return (
  <form className="space-y-6 max-w-2xl mx-auto p-4 md:p-6">
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {/* Left column */}
      <div className="space-y-4">
        <ValidatedInput label="First Name" {...register('firstName')} />
        <ValidatedInput label="Email" type="email" {...register('email')} />
      </div>

      {/* Right column */}
      <div className="space-y-4">
        <ValidatedInput label="Last Name" {...register('lastName')} />
        <ValidatedInput label="Phone" type="tel" {...register('phone')} />
      </div>
    </div>

    {/* Full width fields */}
    <Textarea label="Message" rows={4} className="w-full" {...register('message')} />

    <Button type="submit" className="w-full md:w-auto">
      Submit
    </Button>
  </form>
);
```

Remember: Forms are the primary interface between users and your application. Make them bulletproof, accessible, and delightful to use.
